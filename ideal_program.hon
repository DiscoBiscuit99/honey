# CONSIDERATIONS
# type examples:
# - result: []Token ! LexingError
# - option: char?
# - in this sense, the question mark `?` denotes something that maybe is, and the bang `!` denotes something that should be (*or else*!).
# or:
# - result: Result([]Token, LexingError)
# - optional: Maybe(char)
# - this is quite self-explanatory. (descriptive names)
# potentially, implement: 
# - result: Result([]Token, LexingError)
# - optional: Maybe(char)
# and then implement a superset on top that coerces into it on compilation.
# so:
# - []Token ! LexingError becomes Result([]Token, LexingError)
# - char? becomes Maybe(char)
# on compilation.
#
# if we choose to do it this way, that probably means that the option and result types should be part of the language's standard library.
# thus, we should have a way to import that.

use std.result.Result;
use std.option.Maybe;

let source: comptime string = "let a: number = 0;"

# entry point of the program
let main: () -> nil {
  let tokens: []Token = Lexer.parse(source);
};

let Token: enum = {
  Let,
  Identifier(string),
  Colon,
  NumberKeyword,
  Equal,
  NumberLiteral(string),
  SemiColon,
};

# declaration of structs and other data types
let Lexer: struct = {
  input: string,
  position: uint,
  tokens: []Token,

  let LexingError: enum = {
    Failed,
  };

  let public parse: (input: string) -> []Token ! LexingError = {
    let mutable lexer: Lexer = Lexer.new(input);

    while lexer.peek()? {
      let next: char =
        lexer
          .consume() ! LexingError.Failed;

      if next.is_numeric(10) {
        lexer.parse_numeric()!;
      } else if next.is_alpha {
        lexer.parse_identifier()!;
      } else {
        # match statements should be exhaustive (enforce!)
        match next {
          ':' then lexer.parse_colon()!,
          ';' then lexer.parse_semicolon()!,
          '=' then lexer.paser_equal()!,
        };
      };
    }

    lexer.tokens
  };

  let new: (input: string) -> Lexer = {
    .{
      input,
      position = 0,
      tokens = [],
    }
  };

  let peek: (self: &Lexer) -> char? = {
    self.input[self.position]
  };

  let consume: (self: &Lexer) -> char? = {
    let next: char = self.input[self.position];
    self.position += 1;
    next
  };

  let parse_numeric(self: &Lexer) -> nil ! LexingError {
    todo();
  }

  let parse_identifier(self: &Lexer) -> nil ! LexingError {
    todo();
  }

  let parse_colon(self: &Lexer) -> nil ! LexingError {
    let next: char = self.consume() ! LexingError.Failed;
    if next != ':' {
      return LexingError.Failed;
    }
    self.tokens.push(Token.Colon);
  }

  let parse_semicolon(self: &Lexer) -> nil ! LexingError {
    let next: char = self.consume() ! LexingError.Failed;
    if next != ';' {
      return LexingError.Failed;
    }
    self.tokens.push(Token.SemiColon);
  }

  let parse_equal(self: &Lexer) -> nil ! LexingError {
    let next: char = self.consume() ! LexingError.Failed;
    if next != '=' {
      return LexingError.Failed;
    }
    self.tokens.push(Token.Equal);
  }
};
